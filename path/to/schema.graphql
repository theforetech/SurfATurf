# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

type FileOutput {
    id: Int
    sport_id: Int
    turf_id: bigint
    url: String!
    user_id: String
}

"columns and relationships of \"bookings\""
type bookings {
    booking_status: Boolean!
    contact_name: String!
    contact_phone: String!
    created_at: timestamptz
    "An object relationship"
    facility: facilities!
    facility_id: Int!
    id: uuid!
    payment_status: payment_status_enum_enum
    "An object relationship"
    payment_status_enum: payment_status_enum
    "An array relationship"
    payments(
        "distinct select on columns"
        distinct_on: [payments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payments_order_by!],
        "filter the rows returned"
        where: payments_bool_exp
    ): [payments!]!
    "An aggregate relationship"
    payments_aggregate(
        "distinct select on columns"
        distinct_on: [payments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payments_order_by!],
        "filter the rows returned"
        where: payments_bool_exp
    ): payments_aggregate!
    reservation_date: date!
    reservation_end_time: timestamptz!
    reservation_start_time: timestamptz!
    "An object relationship"
    slot: slots!
    slot_id: bigint!
    split_amount: Int!
    split_members: Int!
    split_payment: Boolean!
    updated_at: timestamptz
    "An object relationship"
    user: user!
    user_id: String!
}

"aggregated selection of \"bookings\""
type bookings_aggregate {
    aggregate: bookings_aggregate_fields
    nodes: [bookings!]!
}

"aggregate fields of \"bookings\""
type bookings_aggregate_fields {
    avg: bookings_avg_fields
    count(columns: [bookings_select_column!], distinct: Boolean): Int!
    max: bookings_max_fields
    min: bookings_min_fields
    stddev: bookings_stddev_fields
    stddev_pop: bookings_stddev_pop_fields
    stddev_samp: bookings_stddev_samp_fields
    sum: bookings_sum_fields
    var_pop: bookings_var_pop_fields
    var_samp: bookings_var_samp_fields
    variance: bookings_variance_fields
}

"aggregate avg on columns"
type bookings_avg_fields {
    facility_id: Float
    slot_id: Float
    split_amount: Float
    split_members: Float
}

"aggregate max on columns"
type bookings_max_fields {
    contact_name: String
    contact_phone: String
    created_at: timestamptz
    facility_id: Int
    id: uuid
    reservation_date: date
    reservation_end_time: timestamptz
    reservation_start_time: timestamptz
    slot_id: bigint
    split_amount: Int
    split_members: Int
    updated_at: timestamptz
    user_id: String
}

"aggregate min on columns"
type bookings_min_fields {
    contact_name: String
    contact_phone: String
    created_at: timestamptz
    facility_id: Int
    id: uuid
    reservation_date: date
    reservation_end_time: timestamptz
    reservation_start_time: timestamptz
    slot_id: bigint
    split_amount: Int
    split_members: Int
    updated_at: timestamptz
    user_id: String
}

"response of any mutation on the table \"bookings\""
type bookings_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [bookings!]!
}

"aggregate stddev on columns"
type bookings_stddev_fields {
    facility_id: Float
    slot_id: Float
    split_amount: Float
    split_members: Float
}

"aggregate stddev_pop on columns"
type bookings_stddev_pop_fields {
    facility_id: Float
    slot_id: Float
    split_amount: Float
    split_members: Float
}

"aggregate stddev_samp on columns"
type bookings_stddev_samp_fields {
    facility_id: Float
    slot_id: Float
    split_amount: Float
    split_members: Float
}

"aggregate sum on columns"
type bookings_sum_fields {
    facility_id: Int
    slot_id: bigint
    split_amount: Int
    split_members: Int
}

"aggregate var_pop on columns"
type bookings_var_pop_fields {
    facility_id: Float
    slot_id: Float
    split_amount: Float
    split_members: Float
}

"aggregate var_samp on columns"
type bookings_var_samp_fields {
    facility_id: Float
    slot_id: Float
    split_amount: Float
    split_members: Float
}

"aggregate variance on columns"
type bookings_variance_fields {
    facility_id: Float
    slot_id: Float
    split_amount: Float
    split_members: Float
}

"columns and relationships of \"facilities\""
type facilities {
    "An array relationship"
    bookings(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): [bookings!]!
    "An aggregate relationship"
    bookings_aggregate(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): bookings_aggregate!
    id: Int!
    name: String!
    price: Int!
    "An array relationship"
    slots(
        "distinct select on columns"
        distinct_on: [slots_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [slots_order_by!],
        "filter the rows returned"
        where: slots_bool_exp
    ): [slots!]!
    "An aggregate relationship"
    slots_aggregate(
        "distinct select on columns"
        distinct_on: [slots_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [slots_order_by!],
        "filter the rows returned"
        where: slots_bool_exp
    ): slots_aggregate!
    "An object relationship"
    sport: sport!
    sport_id: Int!
    "An object relationship"
    turf: turf!
    turf_id: bigint!
}

"aggregated selection of \"facilities\""
type facilities_aggregate {
    aggregate: facilities_aggregate_fields
    nodes: [facilities!]!
}

"aggregate fields of \"facilities\""
type facilities_aggregate_fields {
    avg: facilities_avg_fields
    count(columns: [facilities_select_column!], distinct: Boolean): Int!
    max: facilities_max_fields
    min: facilities_min_fields
    stddev: facilities_stddev_fields
    stddev_pop: facilities_stddev_pop_fields
    stddev_samp: facilities_stddev_samp_fields
    sum: facilities_sum_fields
    var_pop: facilities_var_pop_fields
    var_samp: facilities_var_samp_fields
    variance: facilities_variance_fields
}

"aggregate avg on columns"
type facilities_avg_fields {
    id: Float
    price: Float
    sport_id: Float
    turf_id: Float
}

"aggregate max on columns"
type facilities_max_fields {
    id: Int
    name: String
    price: Int
    sport_id: Int
    turf_id: bigint
}

"aggregate min on columns"
type facilities_min_fields {
    id: Int
    name: String
    price: Int
    sport_id: Int
    turf_id: bigint
}

"response of any mutation on the table \"facilities\""
type facilities_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [facilities!]!
}

"aggregate stddev on columns"
type facilities_stddev_fields {
    id: Float
    price: Float
    sport_id: Float
    turf_id: Float
}

"aggregate stddev_pop on columns"
type facilities_stddev_pop_fields {
    id: Float
    price: Float
    sport_id: Float
    turf_id: Float
}

"aggregate stddev_samp on columns"
type facilities_stddev_samp_fields {
    id: Float
    price: Float
    sport_id: Float
    turf_id: Float
}

"aggregate sum on columns"
type facilities_sum_fields {
    id: Int
    price: Int
    sport_id: Int
    turf_id: bigint
}

"aggregate var_pop on columns"
type facilities_var_pop_fields {
    id: Float
    price: Float
    sport_id: Float
    turf_id: Float
}

"aggregate var_samp on columns"
type facilities_var_samp_fields {
    id: Float
    price: Float
    sport_id: Float
    turf_id: Float
}

"aggregate variance on columns"
type facilities_variance_fields {
    id: Float
    price: Float
    sport_id: Float
    turf_id: Float
}

"columns and relationships of \"images\""
type images {
    id: bigint!
    "An object relationship"
    sport: sport
    sport_id: Int
    "An object relationship"
    turf: turf
    turf_id: bigint
    url: String!
    "An object relationship"
    user: user
    user_id: String
}

"aggregated selection of \"images\""
type images_aggregate {
    aggregate: images_aggregate_fields
    nodes: [images!]!
}

"aggregate fields of \"images\""
type images_aggregate_fields {
    avg: images_avg_fields
    count(columns: [images_select_column!], distinct: Boolean): Int!
    max: images_max_fields
    min: images_min_fields
    stddev: images_stddev_fields
    stddev_pop: images_stddev_pop_fields
    stddev_samp: images_stddev_samp_fields
    sum: images_sum_fields
    var_pop: images_var_pop_fields
    var_samp: images_var_samp_fields
    variance: images_variance_fields
}

"aggregate avg on columns"
type images_avg_fields {
    id: Float
    sport_id: Float
    turf_id: Float
}

"aggregate max on columns"
type images_max_fields {
    id: bigint
    sport_id: Int
    turf_id: bigint
    url: String
    user_id: String
}

"aggregate min on columns"
type images_min_fields {
    id: bigint
    sport_id: Int
    turf_id: bigint
    url: String
    user_id: String
}

"response of any mutation on the table \"images\""
type images_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [images!]!
}

"aggregate stddev on columns"
type images_stddev_fields {
    id: Float
    sport_id: Float
    turf_id: Float
}

"aggregate stddev_pop on columns"
type images_stddev_pop_fields {
    id: Float
    sport_id: Float
    turf_id: Float
}

"aggregate stddev_samp on columns"
type images_stddev_samp_fields {
    id: Float
    sport_id: Float
    turf_id: Float
}

"aggregate sum on columns"
type images_sum_fields {
    id: bigint
    sport_id: Int
    turf_id: bigint
}

"aggregate var_pop on columns"
type images_var_pop_fields {
    id: Float
    sport_id: Float
    turf_id: Float
}

"aggregate var_samp on columns"
type images_var_samp_fields {
    id: Float
    sport_id: Float
    turf_id: Float
}

"aggregate variance on columns"
type images_variance_fields {
    id: Float
    sport_id: Float
    turf_id: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"bookings\""
    delete_bookings(
        "filter the rows which have to be deleted"
        where: bookings_bool_exp!
    ): bookings_mutation_response
    "delete single row from the table: \"bookings\""
    delete_bookings_by_pk(id: uuid!): bookings
    "delete data from the table: \"facilities\""
    delete_facilities(
        "filter the rows which have to be deleted"
        where: facilities_bool_exp!
    ): facilities_mutation_response
    "delete single row from the table: \"facilities\""
    delete_facilities_by_pk(id: Int!): facilities
    "delete data from the table: \"images\""
    delete_images(
        "filter the rows which have to be deleted"
        where: images_bool_exp!
    ): images_mutation_response
    "delete single row from the table: \"images\""
    delete_images_by_pk(id: bigint!): images
    "delete data from the table: \"payment_status_enum\""
    delete_payment_status_enum(
        "filter the rows which have to be deleted"
        where: payment_status_enum_bool_exp!
    ): payment_status_enum_mutation_response
    "delete single row from the table: \"payment_status_enum\""
    delete_payment_status_enum_by_pk(status: String!): payment_status_enum
    "delete data from the table: \"payments\""
    delete_payments(
        "filter the rows which have to be deleted"
        where: payments_bool_exp!
    ): payments_mutation_response
    "delete single row from the table: \"payments\""
    delete_payments_by_pk(id: uuid!): payments
    "delete data from the table: \"rating\""
    delete_rating(
        "filter the rows which have to be deleted"
        where: rating_bool_exp!
    ): rating_mutation_response
    "delete single row from the table: \"rating\""
    delete_rating_by_pk(id: bigint!): rating
    "delete data from the table: \"slots\""
    delete_slots(
        "filter the rows which have to be deleted"
        where: slots_bool_exp!
    ): slots_mutation_response
    "delete single row from the table: \"slots\""
    delete_slots_by_pk(id: bigint!): slots
    "delete data from the table: \"sport\""
    delete_sport(
        "filter the rows which have to be deleted"
        where: sport_bool_exp!
    ): sport_mutation_response
    "delete single row from the table: \"sport\""
    delete_sport_by_pk(name: String!): sport
    "delete data from the table: \"turf\""
    delete_turf(
        "filter the rows which have to be deleted"
        where: turf_bool_exp!
    ): turf_mutation_response
    "delete single row from the table: \"turf\""
    delete_turf_by_pk(id: bigint!): turf
    "delete data from the table: \"user\""
    delete_user(
        "filter the rows which have to be deleted"
        where: user_bool_exp!
    ): user_mutation_response
    "delete single row from the table: \"user\""
    delete_user_by_pk(user_id: String!): user
    "delete data from the table: \"user_profile\""
    delete_user_profile(
        "filter the rows which have to be deleted"
        where: user_profile_bool_exp!
    ): user_profile_mutation_response
    "delete single row from the table: \"user_profile\""
    delete_user_profile_by_pk(user_id: String!): user_profile
    "delete data from the table: \"vendor\""
    delete_vendor(
        "filter the rows which have to be deleted"
        where: vendor_bool_exp!
    ): vendor_mutation_response
    "delete single row from the table: \"vendor\""
    delete_vendor_by_pk(user_id: String!): vendor
    "insert data into the table: \"bookings\""
    insert_bookings(
        "the rows to be inserted"
        objects: [bookings_insert_input!]!,
        "on conflict condition"
        on_conflict: bookings_on_conflict
    ): bookings_mutation_response
    "insert a single row into the table: \"bookings\""
    insert_bookings_one(
        "the row to be inserted"
        object: bookings_insert_input!,
        "on conflict condition"
        on_conflict: bookings_on_conflict
    ): bookings
    "insert data into the table: \"facilities\""
    insert_facilities(
        "the rows to be inserted"
        objects: [facilities_insert_input!]!,
        "on conflict condition"
        on_conflict: facilities_on_conflict
    ): facilities_mutation_response
    "insert a single row into the table: \"facilities\""
    insert_facilities_one(
        "the row to be inserted"
        object: facilities_insert_input!,
        "on conflict condition"
        on_conflict: facilities_on_conflict
    ): facilities
    "insert data into the table: \"images\""
    insert_images(
        "the rows to be inserted"
        objects: [images_insert_input!]!,
        "on conflict condition"
        on_conflict: images_on_conflict
    ): images_mutation_response
    "insert a single row into the table: \"images\""
    insert_images_one(
        "the row to be inserted"
        object: images_insert_input!,
        "on conflict condition"
        on_conflict: images_on_conflict
    ): images
    "insert data into the table: \"payment_status_enum\""
    insert_payment_status_enum(
        "the rows to be inserted"
        objects: [payment_status_enum_insert_input!]!,
        "on conflict condition"
        on_conflict: payment_status_enum_on_conflict
    ): payment_status_enum_mutation_response
    "insert a single row into the table: \"payment_status_enum\""
    insert_payment_status_enum_one(
        "the row to be inserted"
        object: payment_status_enum_insert_input!,
        "on conflict condition"
        on_conflict: payment_status_enum_on_conflict
    ): payment_status_enum
    "insert data into the table: \"payments\""
    insert_payments(
        "the rows to be inserted"
        objects: [payments_insert_input!]!,
        "on conflict condition"
        on_conflict: payments_on_conflict
    ): payments_mutation_response
    "insert a single row into the table: \"payments\""
    insert_payments_one(
        "the row to be inserted"
        object: payments_insert_input!,
        "on conflict condition"
        on_conflict: payments_on_conflict
    ): payments
    "insert data into the table: \"rating\""
    insert_rating(
        "the rows to be inserted"
        objects: [rating_insert_input!]!,
        "on conflict condition"
        on_conflict: rating_on_conflict
    ): rating_mutation_response
    "insert a single row into the table: \"rating\""
    insert_rating_one(
        "the row to be inserted"
        object: rating_insert_input!,
        "on conflict condition"
        on_conflict: rating_on_conflict
    ): rating
    "insert data into the table: \"slots\""
    insert_slots(
        "the rows to be inserted"
        objects: [slots_insert_input!]!,
        "on conflict condition"
        on_conflict: slots_on_conflict
    ): slots_mutation_response
    "insert a single row into the table: \"slots\""
    insert_slots_one(
        "the row to be inserted"
        object: slots_insert_input!,
        "on conflict condition"
        on_conflict: slots_on_conflict
    ): slots
    "insert data into the table: \"sport\""
    insert_sport(
        "the rows to be inserted"
        objects: [sport_insert_input!]!,
        "on conflict condition"
        on_conflict: sport_on_conflict
    ): sport_mutation_response
    "insert a single row into the table: \"sport\""
    insert_sport_one(
        "the row to be inserted"
        object: sport_insert_input!,
        "on conflict condition"
        on_conflict: sport_on_conflict
    ): sport
    "insert data into the table: \"turf\""
    insert_turf(
        "the rows to be inserted"
        objects: [turf_insert_input!]!,
        "on conflict condition"
        on_conflict: turf_on_conflict
    ): turf_mutation_response
    "insert a single row into the table: \"turf\""
    insert_turf_one(
        "the row to be inserted"
        object: turf_insert_input!,
        "on conflict condition"
        on_conflict: turf_on_conflict
    ): turf
    "insert data into the table: \"user\""
    insert_user(
        "the rows to be inserted"
        objects: [user_insert_input!]!,
        "on conflict condition"
        on_conflict: user_on_conflict
    ): user_mutation_response
    "insert a single row into the table: \"user\""
    insert_user_one(
        "the row to be inserted"
        object: user_insert_input!,
        "on conflict condition"
        on_conflict: user_on_conflict
    ): user
    "insert data into the table: \"user_profile\""
    insert_user_profile(
        "the rows to be inserted"
        objects: [user_profile_insert_input!]!,
        "on conflict condition"
        on_conflict: user_profile_on_conflict
    ): user_profile_mutation_response
    "insert a single row into the table: \"user_profile\""
    insert_user_profile_one(
        "the row to be inserted"
        object: user_profile_insert_input!,
        "on conflict condition"
        on_conflict: user_profile_on_conflict
    ): user_profile
    "insert data into the table: \"vendor\""
    insert_vendor(
        "the rows to be inserted"
        objects: [vendor_insert_input!]!,
        "on conflict condition"
        on_conflict: vendor_on_conflict
    ): vendor_mutation_response
    "insert a single row into the table: \"vendor\""
    insert_vendor_one(
        "the row to be inserted"
        object: vendor_insert_input!,
        "on conflict condition"
        on_conflict: vendor_on_conflict
    ): vendor
    "update data of the table: \"bookings\""
    update_bookings(
        "increments the numeric columns with given value of the filtered values"
        _inc: bookings_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: bookings_set_input,
        "filter the rows which have to be updated"
        where: bookings_bool_exp!
    ): bookings_mutation_response
    "update single row of the table: \"bookings\""
    update_bookings_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: bookings_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: bookings_set_input,
        pk_columns: bookings_pk_columns_input!
    ): bookings
    "update data of the table: \"facilities\""
    update_facilities(
        "increments the numeric columns with given value of the filtered values"
        _inc: facilities_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: facilities_set_input,
        "filter the rows which have to be updated"
        where: facilities_bool_exp!
    ): facilities_mutation_response
    "update single row of the table: \"facilities\""
    update_facilities_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: facilities_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: facilities_set_input,
        pk_columns: facilities_pk_columns_input!
    ): facilities
    "update data of the table: \"images\""
    update_images(
        "increments the numeric columns with given value of the filtered values"
        _inc: images_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: images_set_input,
        "filter the rows which have to be updated"
        where: images_bool_exp!
    ): images_mutation_response
    "update single row of the table: \"images\""
    update_images_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: images_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: images_set_input,
        pk_columns: images_pk_columns_input!
    ): images
    "update data of the table: \"payment_status_enum\""
    update_payment_status_enum(
        "sets the columns of the filtered rows to the given values"
        _set: payment_status_enum_set_input,
        "filter the rows which have to be updated"
        where: payment_status_enum_bool_exp!
    ): payment_status_enum_mutation_response
    "update single row of the table: \"payment_status_enum\""
    update_payment_status_enum_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: payment_status_enum_set_input,
        pk_columns: payment_status_enum_pk_columns_input!
    ): payment_status_enum
    "update data of the table: \"payments\""
    update_payments(
        "sets the columns of the filtered rows to the given values"
        _set: payments_set_input,
        "filter the rows which have to be updated"
        where: payments_bool_exp!
    ): payments_mutation_response
    "update single row of the table: \"payments\""
    update_payments_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: payments_set_input,
        pk_columns: payments_pk_columns_input!
    ): payments
    "update data of the table: \"rating\""
    update_rating(
        "increments the numeric columns with given value of the filtered values"
        _inc: rating_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: rating_set_input,
        "filter the rows which have to be updated"
        where: rating_bool_exp!
    ): rating_mutation_response
    "update single row of the table: \"rating\""
    update_rating_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: rating_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: rating_set_input,
        pk_columns: rating_pk_columns_input!
    ): rating
    "update data of the table: \"slots\""
    update_slots(
        "increments the numeric columns with given value of the filtered values"
        _inc: slots_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: slots_set_input,
        "filter the rows which have to be updated"
        where: slots_bool_exp!
    ): slots_mutation_response
    "update single row of the table: \"slots\""
    update_slots_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: slots_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: slots_set_input,
        pk_columns: slots_pk_columns_input!
    ): slots
    "update data of the table: \"sport\""
    update_sport(
        "increments the numeric columns with given value of the filtered values"
        _inc: sport_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: sport_set_input,
        "filter the rows which have to be updated"
        where: sport_bool_exp!
    ): sport_mutation_response
    "update single row of the table: \"sport\""
    update_sport_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: sport_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: sport_set_input,
        pk_columns: sport_pk_columns_input!
    ): sport
    "update data of the table: \"turf\""
    update_turf(
        "increments the numeric columns with given value of the filtered values"
        _inc: turf_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: turf_set_input,
        "filter the rows which have to be updated"
        where: turf_bool_exp!
    ): turf_mutation_response
    "update single row of the table: \"turf\""
    update_turf_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: turf_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: turf_set_input,
        pk_columns: turf_pk_columns_input!
    ): turf
    "update data of the table: \"user\""
    update_user(
        "sets the columns of the filtered rows to the given values"
        _set: user_set_input,
        "filter the rows which have to be updated"
        where: user_bool_exp!
    ): user_mutation_response
    "update single row of the table: \"user\""
    update_user_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: user_set_input,
        pk_columns: user_pk_columns_input!
    ): user
    "update data of the table: \"user_profile\""
    update_user_profile(
        "sets the columns of the filtered rows to the given values"
        _set: user_profile_set_input,
        "filter the rows which have to be updated"
        where: user_profile_bool_exp!
    ): user_profile_mutation_response
    "update single row of the table: \"user_profile\""
    update_user_profile_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: user_profile_set_input,
        pk_columns: user_profile_pk_columns_input!
    ): user_profile
    "update data of the table: \"vendor\""
    update_vendor(
        "sets the columns of the filtered rows to the given values"
        _set: vendor_set_input,
        "filter the rows which have to be updated"
        where: vendor_bool_exp!
    ): vendor_mutation_response
    "update single row of the table: \"vendor\""
    update_vendor_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: vendor_set_input,
        pk_columns: vendor_pk_columns_input!
    ): vendor
    uploadFile(base64str: String!, name: String!, sportID: Int, turfID: bigint, type: String!, userID: String): FileOutput
}

"columns and relationships of \"payment_status_enum\""
type payment_status_enum {
    "An array relationship"
    bookings(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): [bookings!]!
    "An aggregate relationship"
    bookings_aggregate(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): bookings_aggregate!
    description: String!
    status: String!
}

"aggregated selection of \"payment_status_enum\""
type payment_status_enum_aggregate {
    aggregate: payment_status_enum_aggregate_fields
    nodes: [payment_status_enum!]!
}

"aggregate fields of \"payment_status_enum\""
type payment_status_enum_aggregate_fields {
    count(columns: [payment_status_enum_select_column!], distinct: Boolean): Int!
    max: payment_status_enum_max_fields
    min: payment_status_enum_min_fields
}

"aggregate max on columns"
type payment_status_enum_max_fields {
    description: String
    status: String
}

"aggregate min on columns"
type payment_status_enum_min_fields {
    description: String
    status: String
}

"response of any mutation on the table \"payment_status_enum\""
type payment_status_enum_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [payment_status_enum!]!
}

"columns and relationships of \"payments\""
type payments {
    "An object relationship"
    booking: bookings!
    booking_id: uuid!
    created_at: timestamptz!
    id: uuid!
    payment_approved: Boolean!
    payment_obj(
        "JSON select path"
        path: String
    ): json
    payment_status: String!
    updated_at: timestamptz!
}

"aggregated selection of \"payments\""
type payments_aggregate {
    aggregate: payments_aggregate_fields
    nodes: [payments!]!
}

"aggregate fields of \"payments\""
type payments_aggregate_fields {
    count(columns: [payments_select_column!], distinct: Boolean): Int!
    max: payments_max_fields
    min: payments_min_fields
}

"aggregate max on columns"
type payments_max_fields {
    booking_id: uuid
    created_at: timestamptz
    id: uuid
    payment_status: String
    updated_at: timestamptz
}

"aggregate min on columns"
type payments_min_fields {
    booking_id: uuid
    created_at: timestamptz
    id: uuid
    payment_status: String
    updated_at: timestamptz
}

"response of any mutation on the table \"payments\""
type payments_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [payments!]!
}

type query_root {
    "An array relationship"
    bookings(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): [bookings!]!
    "An aggregate relationship"
    bookings_aggregate(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): bookings_aggregate!
    "fetch data from the table: \"bookings\" using primary key columns"
    bookings_by_pk(id: uuid!): bookings
    "An array relationship"
    facilities(
        "distinct select on columns"
        distinct_on: [facilities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [facilities_order_by!],
        "filter the rows returned"
        where: facilities_bool_exp
    ): [facilities!]!
    "An aggregate relationship"
    facilities_aggregate(
        "distinct select on columns"
        distinct_on: [facilities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [facilities_order_by!],
        "filter the rows returned"
        where: facilities_bool_exp
    ): facilities_aggregate!
    "fetch data from the table: \"facilities\" using primary key columns"
    facilities_by_pk(id: Int!): facilities
    "An array relationship"
    images(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): [images!]!
    "An aggregate relationship"
    images_aggregate(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): images_aggregate!
    "fetch data from the table: \"images\" using primary key columns"
    images_by_pk(id: bigint!): images
    "fetch data from the table: \"payment_status_enum\""
    payment_status_enum(
        "distinct select on columns"
        distinct_on: [payment_status_enum_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payment_status_enum_order_by!],
        "filter the rows returned"
        where: payment_status_enum_bool_exp
    ): [payment_status_enum!]!
    "fetch aggregated fields from the table: \"payment_status_enum\""
    payment_status_enum_aggregate(
        "distinct select on columns"
        distinct_on: [payment_status_enum_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payment_status_enum_order_by!],
        "filter the rows returned"
        where: payment_status_enum_bool_exp
    ): payment_status_enum_aggregate!
    "fetch data from the table: \"payment_status_enum\" using primary key columns"
    payment_status_enum_by_pk(status: String!): payment_status_enum
    "An array relationship"
    payments(
        "distinct select on columns"
        distinct_on: [payments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payments_order_by!],
        "filter the rows returned"
        where: payments_bool_exp
    ): [payments!]!
    "An aggregate relationship"
    payments_aggregate(
        "distinct select on columns"
        distinct_on: [payments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payments_order_by!],
        "filter the rows returned"
        where: payments_bool_exp
    ): payments_aggregate!
    "fetch data from the table: \"payments\" using primary key columns"
    payments_by_pk(id: uuid!): payments
    "fetch data from the table: \"rating\""
    rating(
        "distinct select on columns"
        distinct_on: [rating_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [rating_order_by!],
        "filter the rows returned"
        where: rating_bool_exp
    ): [rating!]!
    "fetch aggregated fields from the table: \"rating\""
    rating_aggregate(
        "distinct select on columns"
        distinct_on: [rating_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [rating_order_by!],
        "filter the rows returned"
        where: rating_bool_exp
    ): rating_aggregate!
    "fetch data from the table: \"rating\" using primary key columns"
    rating_by_pk(id: bigint!): rating
    "An array relationship"
    slots(
        "distinct select on columns"
        distinct_on: [slots_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [slots_order_by!],
        "filter the rows returned"
        where: slots_bool_exp
    ): [slots!]!
    "An aggregate relationship"
    slots_aggregate(
        "distinct select on columns"
        distinct_on: [slots_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [slots_order_by!],
        "filter the rows returned"
        where: slots_bool_exp
    ): slots_aggregate!
    "fetch data from the table: \"slots\" using primary key columns"
    slots_by_pk(id: bigint!): slots
    "fetch data from the table: \"sport\""
    sport(
        "distinct select on columns"
        distinct_on: [sport_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sport_order_by!],
        "filter the rows returned"
        where: sport_bool_exp
    ): [sport!]!
    "fetch aggregated fields from the table: \"sport\""
    sport_aggregate(
        "distinct select on columns"
        distinct_on: [sport_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sport_order_by!],
        "filter the rows returned"
        where: sport_bool_exp
    ): sport_aggregate!
    "fetch data from the table: \"sport\" using primary key columns"
    sport_by_pk(name: String!): sport
    "fetch data from the table: \"turf\""
    turf(
        "distinct select on columns"
        distinct_on: [turf_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [turf_order_by!],
        "filter the rows returned"
        where: turf_bool_exp
    ): [turf!]!
    "fetch aggregated fields from the table: \"turf\""
    turf_aggregate(
        "distinct select on columns"
        distinct_on: [turf_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [turf_order_by!],
        "filter the rows returned"
        where: turf_bool_exp
    ): turf_aggregate!
    "fetch data from the table: \"turf\" using primary key columns"
    turf_by_pk(id: bigint!): turf
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinct_on: [user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_order_by!],
        "filter the rows returned"
        where: user_bool_exp
    ): [user!]!
    "fetch aggregated fields from the table: \"user\""
    user_aggregate(
        "distinct select on columns"
        distinct_on: [user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_order_by!],
        "filter the rows returned"
        where: user_bool_exp
    ): user_aggregate!
    "fetch data from the table: \"user\" using primary key columns"
    user_by_pk(user_id: String!): user
    "fetch data from the table: \"user_profile\""
    user_profile(
        "distinct select on columns"
        distinct_on: [user_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_profile_order_by!],
        "filter the rows returned"
        where: user_profile_bool_exp
    ): [user_profile!]!
    "fetch aggregated fields from the table: \"user_profile\""
    user_profile_aggregate(
        "distinct select on columns"
        distinct_on: [user_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_profile_order_by!],
        "filter the rows returned"
        where: user_profile_bool_exp
    ): user_profile_aggregate!
    "fetch data from the table: \"user_profile\" using primary key columns"
    user_profile_by_pk(user_id: String!): user_profile
    "fetch data from the table: \"vendor\""
    vendor(
        "distinct select on columns"
        distinct_on: [vendor_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [vendor_order_by!],
        "filter the rows returned"
        where: vendor_bool_exp
    ): [vendor!]!
    "fetch aggregated fields from the table: \"vendor\""
    vendor_aggregate(
        "distinct select on columns"
        distinct_on: [vendor_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [vendor_order_by!],
        "filter the rows returned"
        where: vendor_bool_exp
    ): vendor_aggregate!
    "fetch data from the table: \"vendor\" using primary key columns"
    vendor_by_pk(user_id: String!): vendor
}

"columns and relationships of \"rating\""
type rating {
    id: bigint!
    ratings: Int!
    review: String
    "An object relationship"
    turf: turf!
    turf_id: bigint!
    "An object relationship"
    user: user!
    user_id: String!
}

"aggregated selection of \"rating\""
type rating_aggregate {
    aggregate: rating_aggregate_fields
    nodes: [rating!]!
}

"aggregate fields of \"rating\""
type rating_aggregate_fields {
    avg: rating_avg_fields
    count(columns: [rating_select_column!], distinct: Boolean): Int!
    max: rating_max_fields
    min: rating_min_fields
    stddev: rating_stddev_fields
    stddev_pop: rating_stddev_pop_fields
    stddev_samp: rating_stddev_samp_fields
    sum: rating_sum_fields
    var_pop: rating_var_pop_fields
    var_samp: rating_var_samp_fields
    variance: rating_variance_fields
}

"aggregate avg on columns"
type rating_avg_fields {
    id: Float
    ratings: Float
    turf_id: Float
}

"aggregate max on columns"
type rating_max_fields {
    id: bigint
    ratings: Int
    review: String
    turf_id: bigint
    user_id: String
}

"aggregate min on columns"
type rating_min_fields {
    id: bigint
    ratings: Int
    review: String
    turf_id: bigint
    user_id: String
}

"response of any mutation on the table \"rating\""
type rating_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [rating!]!
}

"aggregate stddev on columns"
type rating_stddev_fields {
    id: Float
    ratings: Float
    turf_id: Float
}

"aggregate stddev_pop on columns"
type rating_stddev_pop_fields {
    id: Float
    ratings: Float
    turf_id: Float
}

"aggregate stddev_samp on columns"
type rating_stddev_samp_fields {
    id: Float
    ratings: Float
    turf_id: Float
}

"aggregate sum on columns"
type rating_sum_fields {
    id: bigint
    ratings: Int
    turf_id: bigint
}

"aggregate var_pop on columns"
type rating_var_pop_fields {
    id: Float
    ratings: Float
    turf_id: Float
}

"aggregate var_samp on columns"
type rating_var_samp_fields {
    id: Float
    ratings: Float
    turf_id: Float
}

"aggregate variance on columns"
type rating_variance_fields {
    id: Float
    ratings: Float
    turf_id: Float
}

"columns and relationships of \"slots\""
type slots {
    "An array relationship"
    bookings(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): [bookings!]!
    "An aggregate relationship"
    bookings_aggregate(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): bookings_aggregate!
    end_time: timestamptz!
    "An object relationship"
    facility: facilities
    facility_id: Int
    id: bigint!
    start_time: timestamptz!
}

"aggregated selection of \"slots\""
type slots_aggregate {
    aggregate: slots_aggregate_fields
    nodes: [slots!]!
}

"aggregate fields of \"slots\""
type slots_aggregate_fields {
    avg: slots_avg_fields
    count(columns: [slots_select_column!], distinct: Boolean): Int!
    max: slots_max_fields
    min: slots_min_fields
    stddev: slots_stddev_fields
    stddev_pop: slots_stddev_pop_fields
    stddev_samp: slots_stddev_samp_fields
    sum: slots_sum_fields
    var_pop: slots_var_pop_fields
    var_samp: slots_var_samp_fields
    variance: slots_variance_fields
}

"aggregate avg on columns"
type slots_avg_fields {
    facility_id: Float
    id: Float
}

"aggregate max on columns"
type slots_max_fields {
    end_time: timestamptz
    facility_id: Int
    id: bigint
    start_time: timestamptz
}

"aggregate min on columns"
type slots_min_fields {
    end_time: timestamptz
    facility_id: Int
    id: bigint
    start_time: timestamptz
}

"response of any mutation on the table \"slots\""
type slots_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [slots!]!
}

"aggregate stddev on columns"
type slots_stddev_fields {
    facility_id: Float
    id: Float
}

"aggregate stddev_pop on columns"
type slots_stddev_pop_fields {
    facility_id: Float
    id: Float
}

"aggregate stddev_samp on columns"
type slots_stddev_samp_fields {
    facility_id: Float
    id: Float
}

"aggregate sum on columns"
type slots_sum_fields {
    facility_id: Int
    id: bigint
}

"aggregate var_pop on columns"
type slots_var_pop_fields {
    facility_id: Float
    id: Float
}

"aggregate var_samp on columns"
type slots_var_samp_fields {
    facility_id: Float
    id: Float
}

"aggregate variance on columns"
type slots_variance_fields {
    facility_id: Float
    id: Float
}

"columns and relationships of \"sport\""
type sport {
    disabled: Boolean!
    "An array relationship"
    facilities(
        "distinct select on columns"
        distinct_on: [facilities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [facilities_order_by!],
        "filter the rows returned"
        where: facilities_bool_exp
    ): [facilities!]!
    "An aggregate relationship"
    facilities_aggregate(
        "distinct select on columns"
        distinct_on: [facilities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [facilities_order_by!],
        "filter the rows returned"
        where: facilities_bool_exp
    ): facilities_aggregate!
    id: Int!
    "An array relationship"
    images(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): [images!]!
    "An aggregate relationship"
    images_aggregate(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): images_aggregate!
    name: String!
}

"aggregated selection of \"sport\""
type sport_aggregate {
    aggregate: sport_aggregate_fields
    nodes: [sport!]!
}

"aggregate fields of \"sport\""
type sport_aggregate_fields {
    avg: sport_avg_fields
    count(columns: [sport_select_column!], distinct: Boolean): Int!
    max: sport_max_fields
    min: sport_min_fields
    stddev: sport_stddev_fields
    stddev_pop: sport_stddev_pop_fields
    stddev_samp: sport_stddev_samp_fields
    sum: sport_sum_fields
    var_pop: sport_var_pop_fields
    var_samp: sport_var_samp_fields
    variance: sport_variance_fields
}

"aggregate avg on columns"
type sport_avg_fields {
    id: Float
}

"aggregate max on columns"
type sport_max_fields {
    id: Int
    name: String
}

"aggregate min on columns"
type sport_min_fields {
    id: Int
    name: String
}

"response of any mutation on the table \"sport\""
type sport_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [sport!]!
}

"aggregate stddev on columns"
type sport_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type sport_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type sport_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type sport_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type sport_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type sport_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type sport_variance_fields {
    id: Float
}

type subscription_root {
    "An array relationship"
    bookings(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): [bookings!]!
    "An aggregate relationship"
    bookings_aggregate(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): bookings_aggregate!
    "fetch data from the table: \"bookings\" using primary key columns"
    bookings_by_pk(id: uuid!): bookings
    "An array relationship"
    facilities(
        "distinct select on columns"
        distinct_on: [facilities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [facilities_order_by!],
        "filter the rows returned"
        where: facilities_bool_exp
    ): [facilities!]!
    "An aggregate relationship"
    facilities_aggregate(
        "distinct select on columns"
        distinct_on: [facilities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [facilities_order_by!],
        "filter the rows returned"
        where: facilities_bool_exp
    ): facilities_aggregate!
    "fetch data from the table: \"facilities\" using primary key columns"
    facilities_by_pk(id: Int!): facilities
    "An array relationship"
    images(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): [images!]!
    "An aggregate relationship"
    images_aggregate(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): images_aggregate!
    "fetch data from the table: \"images\" using primary key columns"
    images_by_pk(id: bigint!): images
    "fetch data from the table: \"payment_status_enum\""
    payment_status_enum(
        "distinct select on columns"
        distinct_on: [payment_status_enum_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payment_status_enum_order_by!],
        "filter the rows returned"
        where: payment_status_enum_bool_exp
    ): [payment_status_enum!]!
    "fetch aggregated fields from the table: \"payment_status_enum\""
    payment_status_enum_aggregate(
        "distinct select on columns"
        distinct_on: [payment_status_enum_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payment_status_enum_order_by!],
        "filter the rows returned"
        where: payment_status_enum_bool_exp
    ): payment_status_enum_aggregate!
    "fetch data from the table: \"payment_status_enum\" using primary key columns"
    payment_status_enum_by_pk(status: String!): payment_status_enum
    "An array relationship"
    payments(
        "distinct select on columns"
        distinct_on: [payments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payments_order_by!],
        "filter the rows returned"
        where: payments_bool_exp
    ): [payments!]!
    "An aggregate relationship"
    payments_aggregate(
        "distinct select on columns"
        distinct_on: [payments_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [payments_order_by!],
        "filter the rows returned"
        where: payments_bool_exp
    ): payments_aggregate!
    "fetch data from the table: \"payments\" using primary key columns"
    payments_by_pk(id: uuid!): payments
    "fetch data from the table: \"rating\""
    rating(
        "distinct select on columns"
        distinct_on: [rating_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [rating_order_by!],
        "filter the rows returned"
        where: rating_bool_exp
    ): [rating!]!
    "fetch aggregated fields from the table: \"rating\""
    rating_aggregate(
        "distinct select on columns"
        distinct_on: [rating_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [rating_order_by!],
        "filter the rows returned"
        where: rating_bool_exp
    ): rating_aggregate!
    "fetch data from the table: \"rating\" using primary key columns"
    rating_by_pk(id: bigint!): rating
    "An array relationship"
    slots(
        "distinct select on columns"
        distinct_on: [slots_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [slots_order_by!],
        "filter the rows returned"
        where: slots_bool_exp
    ): [slots!]!
    "An aggregate relationship"
    slots_aggregate(
        "distinct select on columns"
        distinct_on: [slots_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [slots_order_by!],
        "filter the rows returned"
        where: slots_bool_exp
    ): slots_aggregate!
    "fetch data from the table: \"slots\" using primary key columns"
    slots_by_pk(id: bigint!): slots
    "fetch data from the table: \"sport\""
    sport(
        "distinct select on columns"
        distinct_on: [sport_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sport_order_by!],
        "filter the rows returned"
        where: sport_bool_exp
    ): [sport!]!
    "fetch aggregated fields from the table: \"sport\""
    sport_aggregate(
        "distinct select on columns"
        distinct_on: [sport_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [sport_order_by!],
        "filter the rows returned"
        where: sport_bool_exp
    ): sport_aggregate!
    "fetch data from the table: \"sport\" using primary key columns"
    sport_by_pk(name: String!): sport
    "fetch data from the table: \"turf\""
    turf(
        "distinct select on columns"
        distinct_on: [turf_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [turf_order_by!],
        "filter the rows returned"
        where: turf_bool_exp
    ): [turf!]!
    "fetch aggregated fields from the table: \"turf\""
    turf_aggregate(
        "distinct select on columns"
        distinct_on: [turf_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [turf_order_by!],
        "filter the rows returned"
        where: turf_bool_exp
    ): turf_aggregate!
    "fetch data from the table: \"turf\" using primary key columns"
    turf_by_pk(id: bigint!): turf
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinct_on: [user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_order_by!],
        "filter the rows returned"
        where: user_bool_exp
    ): [user!]!
    "fetch aggregated fields from the table: \"user\""
    user_aggregate(
        "distinct select on columns"
        distinct_on: [user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_order_by!],
        "filter the rows returned"
        where: user_bool_exp
    ): user_aggregate!
    "fetch data from the table: \"user\" using primary key columns"
    user_by_pk(user_id: String!): user
    "fetch data from the table: \"user_profile\""
    user_profile(
        "distinct select on columns"
        distinct_on: [user_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_profile_order_by!],
        "filter the rows returned"
        where: user_profile_bool_exp
    ): [user_profile!]!
    "fetch aggregated fields from the table: \"user_profile\""
    user_profile_aggregate(
        "distinct select on columns"
        distinct_on: [user_profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_profile_order_by!],
        "filter the rows returned"
        where: user_profile_bool_exp
    ): user_profile_aggregate!
    "fetch data from the table: \"user_profile\" using primary key columns"
    user_profile_by_pk(user_id: String!): user_profile
    "fetch data from the table: \"vendor\""
    vendor(
        "distinct select on columns"
        distinct_on: [vendor_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [vendor_order_by!],
        "filter the rows returned"
        where: vendor_bool_exp
    ): [vendor!]!
    "fetch aggregated fields from the table: \"vendor\""
    vendor_aggregate(
        "distinct select on columns"
        distinct_on: [vendor_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [vendor_order_by!],
        "filter the rows returned"
        where: vendor_bool_exp
    ): vendor_aggregate!
    "fetch data from the table: \"vendor\" using primary key columns"
    vendor_by_pk(user_id: String!): vendor
}

"columns and relationships of \"turf\""
type turf {
    address: String!
    city: String!
    "An array relationship"
    facilities(
        "distinct select on columns"
        distinct_on: [facilities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [facilities_order_by!],
        "filter the rows returned"
        where: facilities_bool_exp
    ): [facilities!]!
    "An aggregate relationship"
    facilities_aggregate(
        "distinct select on columns"
        distinct_on: [facilities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [facilities_order_by!],
        "filter the rows returned"
        where: facilities_bool_exp
    ): facilities_aggregate!
    id: bigint!
    "An array relationship"
    images(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): [images!]!
    "An aggregate relationship"
    images_aggregate(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): images_aggregate!
    name: String!
    pincode: Int!
    "A computed field, executes function \"turf_rating\""
    rating: float8
    "An array relationship"
    ratings(
        "distinct select on columns"
        distinct_on: [rating_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [rating_order_by!],
        "filter the rows returned"
        where: rating_bool_exp
    ): [rating!]!
    "An aggregate relationship"
    ratings_aggregate(
        "distinct select on columns"
        distinct_on: [rating_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [rating_order_by!],
        "filter the rows returned"
        where: rating_bool_exp
    ): rating_aggregate!
    state: String!
    vendor_id: String!
    "An object relationship"
    vendor_profile: vendor!
}

"aggregated selection of \"turf\""
type turf_aggregate {
    aggregate: turf_aggregate_fields
    nodes: [turf!]!
}

"aggregate fields of \"turf\""
type turf_aggregate_fields {
    avg: turf_avg_fields
    count(columns: [turf_select_column!], distinct: Boolean): Int!
    max: turf_max_fields
    min: turf_min_fields
    stddev: turf_stddev_fields
    stddev_pop: turf_stddev_pop_fields
    stddev_samp: turf_stddev_samp_fields
    sum: turf_sum_fields
    var_pop: turf_var_pop_fields
    var_samp: turf_var_samp_fields
    variance: turf_variance_fields
}

"aggregate avg on columns"
type turf_avg_fields {
    id: Float
    pincode: Float
}

"aggregate max on columns"
type turf_max_fields {
    address: String
    city: String
    id: bigint
    name: String
    pincode: Int
    state: String
    vendor_id: String
}

"aggregate min on columns"
type turf_min_fields {
    address: String
    city: String
    id: bigint
    name: String
    pincode: Int
    state: String
    vendor_id: String
}

"response of any mutation on the table \"turf\""
type turf_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [turf!]!
}

"aggregate stddev on columns"
type turf_stddev_fields {
    id: Float
    pincode: Float
}

"aggregate stddev_pop on columns"
type turf_stddev_pop_fields {
    id: Float
    pincode: Float
}

"aggregate stddev_samp on columns"
type turf_stddev_samp_fields {
    id: Float
    pincode: Float
}

"aggregate sum on columns"
type turf_sum_fields {
    id: bigint
    pincode: Int
}

"aggregate var_pop on columns"
type turf_var_pop_fields {
    id: Float
    pincode: Float
}

"aggregate var_samp on columns"
type turf_var_samp_fields {
    id: Float
    pincode: Float
}

"aggregate variance on columns"
type turf_variance_fields {
    id: Float
    pincode: Float
}

"columns and relationships of \"user\""
type user {
    "An array relationship"
    bookings(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): [bookings!]!
    "An aggregate relationship"
    bookings_aggregate(
        "distinct select on columns"
        distinct_on: [bookings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [bookings_order_by!],
        "filter the rows returned"
        where: bookings_bool_exp
    ): bookings_aggregate!
    email: String
    "An array relationship"
    images(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): [images!]!
    "An aggregate relationship"
    images_aggregate(
        "distinct select on columns"
        distinct_on: [images_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [images_order_by!],
        "filter the rows returned"
        where: images_bool_exp
    ): images_aggregate!
    name: String
    nickname: String
    picture: String
    "An array relationship"
    ratings(
        "distinct select on columns"
        distinct_on: [rating_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [rating_order_by!],
        "filter the rows returned"
        where: rating_bool_exp
    ): [rating!]!
    "An aggregate relationship"
    ratings_aggregate(
        "distinct select on columns"
        distinct_on: [rating_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [rating_order_by!],
        "filter the rows returned"
        where: rating_bool_exp
    ): rating_aggregate!
    user_id: String!
    "An object relationship"
    user_profile: user_profile!
    "An object relationship"
    vendor: vendor
}

"aggregated selection of \"user\""
type user_aggregate {
    aggregate: user_aggregate_fields
    nodes: [user!]!
}

"aggregate fields of \"user\""
type user_aggregate_fields {
    count(columns: [user_select_column!], distinct: Boolean): Int!
    max: user_max_fields
    min: user_min_fields
}

"aggregate max on columns"
type user_max_fields {
    email: String
    name: String
    nickname: String
    picture: String
    user_id: String
}

"aggregate min on columns"
type user_min_fields {
    email: String
    name: String
    nickname: String
    picture: String
    user_id: String
}

"response of any mutation on the table \"user\""
type user_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user!]!
}

"columns and relationships of \"user_profile\""
type user_profile {
    default_city: String
    name: String!
    phone_number: String!
    "An object relationship"
    user: user!
    user_id: String!
}

"aggregated selection of \"user_profile\""
type user_profile_aggregate {
    aggregate: user_profile_aggregate_fields
    nodes: [user_profile!]!
}

"aggregate fields of \"user_profile\""
type user_profile_aggregate_fields {
    count(columns: [user_profile_select_column!], distinct: Boolean): Int!
    max: user_profile_max_fields
    min: user_profile_min_fields
}

"aggregate max on columns"
type user_profile_max_fields {
    default_city: String
    name: String
    phone_number: String
    user_id: String
}

"aggregate min on columns"
type user_profile_min_fields {
    default_city: String
    name: String
    phone_number: String
    user_id: String
}

"response of any mutation on the table \"user_profile\""
type user_profile_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_profile!]!
}

"columns and relationships of \"vendor\""
type vendor {
    about: String
    address: String!
    birthDate: date!
    city: String!
    company: String!
    country: String!
    name: String!
    payment_details: String
    phone_number: String!
    state: String!
    "An array relationship"
    turfs(
        "distinct select on columns"
        distinct_on: [turf_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [turf_order_by!],
        "filter the rows returned"
        where: turf_bool_exp
    ): [turf!]!
    "An aggregate relationship"
    turfs_aggregate(
        "distinct select on columns"
        distinct_on: [turf_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [turf_order_by!],
        "filter the rows returned"
        where: turf_bool_exp
    ): turf_aggregate!
    "An object relationship"
    user: user!
    user_id: String!
    website: String
}

"aggregated selection of \"vendor\""
type vendor_aggregate {
    aggregate: vendor_aggregate_fields
    nodes: [vendor!]!
}

"aggregate fields of \"vendor\""
type vendor_aggregate_fields {
    count(columns: [vendor_select_column!], distinct: Boolean): Int!
    max: vendor_max_fields
    min: vendor_min_fields
}

"aggregate max on columns"
type vendor_max_fields {
    about: String
    address: String
    birthDate: date
    city: String
    company: String
    country: String
    name: String
    payment_details: String
    phone_number: String
    state: String
    user_id: String
    website: String
}

"aggregate min on columns"
type vendor_min_fields {
    about: String
    address: String
    birthDate: date
    city: String
    company: String
    country: String
    name: String
    payment_details: String
    phone_number: String
    state: String
    user_id: String
    website: String
}

"response of any mutation on the table \"vendor\""
type vendor_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [vendor!]!
}

"unique or primary key constraints on table \"bookings\""
enum bookings_constraint {
    "unique or primary key constraint"
    bookings_pkey
}

"select columns of table \"bookings\""
enum bookings_select_column {
    "column name"
    booking_status
    "column name"
    contact_name
    "column name"
    contact_phone
    "column name"
    created_at
    "column name"
    facility_id
    "column name"
    id
    "column name"
    payment_status
    "column name"
    reservation_date
    "column name"
    reservation_end_time
    "column name"
    reservation_start_time
    "column name"
    slot_id
    "column name"
    split_amount
    "column name"
    split_members
    "column name"
    split_payment
    "column name"
    updated_at
    "column name"
    user_id
}

"update columns of table \"bookings\""
enum bookings_update_column {
    "column name"
    booking_status
    "column name"
    contact_name
    "column name"
    contact_phone
    "column name"
    created_at
    "column name"
    facility_id
    "column name"
    id
    "column name"
    payment_status
    "column name"
    reservation_date
    "column name"
    reservation_end_time
    "column name"
    reservation_start_time
    "column name"
    slot_id
    "column name"
    split_amount
    "column name"
    split_members
    "column name"
    split_payment
    "column name"
    updated_at
    "column name"
    user_id
}

"unique or primary key constraints on table \"facilities\""
enum facilities_constraint {
    "unique or primary key constraint"
    facilities_pkey
}

"select columns of table \"facilities\""
enum facilities_select_column {
    "column name"
    id
    "column name"
    name
    "column name"
    price
    "column name"
    sport_id
    "column name"
    turf_id
}

"update columns of table \"facilities\""
enum facilities_update_column {
    "column name"
    id
    "column name"
    name
    "column name"
    price
    "column name"
    sport_id
    "column name"
    turf_id
}

"unique or primary key constraints on table \"images\""
enum images_constraint {
    "unique or primary key constraint"
    images_pkey
}

"select columns of table \"images\""
enum images_select_column {
    "column name"
    id
    "column name"
    sport_id
    "column name"
    turf_id
    "column name"
    url
    "column name"
    user_id
}

"update columns of table \"images\""
enum images_update_column {
    "column name"
    id
    "column name"
    sport_id
    "column name"
    turf_id
    "column name"
    url
    "column name"
    user_id
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"payment_status_enum\""
enum payment_status_enum_constraint {
    "unique or primary key constraint"
    payment_status_enum_pkey
}

enum payment_status_enum_enum {
    "Payment Failed"
    failed
    "Payment has been refunded"
    refunded
    "Payment Successful"
    success
}

"select columns of table \"payment_status_enum\""
enum payment_status_enum_select_column {
    "column name"
    description
    "column name"
    status
}

"update columns of table \"payment_status_enum\""
enum payment_status_enum_update_column {
    "column name"
    description
    "column name"
    status
}

"unique or primary key constraints on table \"payments\""
enum payments_constraint {
    "unique or primary key constraint"
    payments_pkey
}

"select columns of table \"payments\""
enum payments_select_column {
    "column name"
    booking_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    payment_approved
    "column name"
    payment_obj
    "column name"
    payment_status
    "column name"
    updated_at
}

"update columns of table \"payments\""
enum payments_update_column {
    "column name"
    booking_id
    "column name"
    created_at
    "column name"
    id
    "column name"
    payment_approved
    "column name"
    payment_obj
    "column name"
    payment_status
    "column name"
    updated_at
}

"unique or primary key constraints on table \"rating\""
enum rating_constraint {
    "unique or primary key constraint"
    rating_pkey
}

"select columns of table \"rating\""
enum rating_select_column {
    "column name"
    id
    "column name"
    ratings
    "column name"
    review
    "column name"
    turf_id
    "column name"
    user_id
}

"update columns of table \"rating\""
enum rating_update_column {
    "column name"
    id
    "column name"
    ratings
    "column name"
    review
    "column name"
    turf_id
    "column name"
    user_id
}

"unique or primary key constraints on table \"slots\""
enum slots_constraint {
    "unique or primary key constraint"
    slots_pkey
}

"select columns of table \"slots\""
enum slots_select_column {
    "column name"
    end_time
    "column name"
    facility_id
    "column name"
    id
    "column name"
    start_time
}

"update columns of table \"slots\""
enum slots_update_column {
    "column name"
    end_time
    "column name"
    facility_id
    "column name"
    id
    "column name"
    start_time
}

"unique or primary key constraints on table \"sport\""
enum sport_constraint {
    "unique or primary key constraint"
    sport_id_key
    "unique or primary key constraint"
    sport_pkey
}

"select columns of table \"sport\""
enum sport_select_column {
    "column name"
    disabled
    "column name"
    id
    "column name"
    name
}

"update columns of table \"sport\""
enum sport_update_column {
    "column name"
    disabled
    "column name"
    id
    "column name"
    name
}

"unique or primary key constraints on table \"turf\""
enum turf_constraint {
    "unique or primary key constraint"
    turf_pkey
}

"select columns of table \"turf\""
enum turf_select_column {
    "column name"
    address
    "column name"
    city
    "column name"
    id
    "column name"
    name
    "column name"
    pincode
    "column name"
    state
    "column name"
    vendor_id
}

"update columns of table \"turf\""
enum turf_update_column {
    "column name"
    address
    "column name"
    city
    "column name"
    id
    "column name"
    name
    "column name"
    pincode
    "column name"
    state
    "column name"
    vendor_id
}

"unique or primary key constraints on table \"user\""
enum user_constraint {
    "unique or primary key constraint"
    user_pkey
}

"unique or primary key constraints on table \"user_profile\""
enum user_profile_constraint {
    "unique or primary key constraint"
    user_profile_phone_number_key
    "unique or primary key constraint"
    user_profile_pkey
}

"select columns of table \"user_profile\""
enum user_profile_select_column {
    "column name"
    default_city
    "column name"
    name
    "column name"
    phone_number
    "column name"
    user_id
}

"update columns of table \"user_profile\""
enum user_profile_update_column {
    "column name"
    default_city
    "column name"
    name
    "column name"
    phone_number
    "column name"
    user_id
}

"select columns of table \"user\""
enum user_select_column {
    "column name"
    email
    "column name"
    name
    "column name"
    nickname
    "column name"
    picture
    "column name"
    user_id
}

"update columns of table \"user\""
enum user_update_column {
    "column name"
    email
    "column name"
    name
    "column name"
    nickname
    "column name"
    picture
    "column name"
    user_id
}

"unique or primary key constraints on table \"vendor\""
enum vendor_constraint {
    "unique or primary key constraint"
    vendorProfile_phoneNumber_key
    "unique or primary key constraint"
    vendorProfile_pkey
    "unique or primary key constraint"
    vendorProfile_userID_key
}

"select columns of table \"vendor\""
enum vendor_select_column {
    "column name"
    about
    "column name"
    address
    "column name"
    birthDate
    "column name"
    city
    "column name"
    company
    "column name"
    country
    "column name"
    name
    "column name"
    payment_details
    "column name"
    phone_number
    "column name"
    state
    "column name"
    user_id
    "column name"
    website
}

"update columns of table \"vendor\""
enum vendor_update_column {
    "column name"
    about
    "column name"
    address
    "column name"
    birthDate
    "column name"
    city
    "column name"
    company
    "column name"
    country
    "column name"
    name
    "column name"
    payment_details
    "column name"
    phone_number
    "column name"
    state
    "column name"
    user_id
    "column name"
    website
}

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
    _eq: bigint
    _gt: bigint
    _gte: bigint
    _in: [bigint!]
    _is_null: Boolean
    _lt: bigint
    _lte: bigint
    _neq: bigint
    _nin: [bigint!]
}

"order by aggregate values of table \"bookings\""
input bookings_aggregate_order_by {
    avg: bookings_avg_order_by
    count: order_by
    max: bookings_max_order_by
    min: bookings_min_order_by
    stddev: bookings_stddev_order_by
    stddev_pop: bookings_stddev_pop_order_by
    stddev_samp: bookings_stddev_samp_order_by
    sum: bookings_sum_order_by
    var_pop: bookings_var_pop_order_by
    var_samp: bookings_var_samp_order_by
    variance: bookings_variance_order_by
}

"input type for inserting array relation for remote table \"bookings\""
input bookings_arr_rel_insert_input {
    data: [bookings_insert_input!]!
    "on conflict condition"
    on_conflict: bookings_on_conflict
}

"order by avg() on columns of table \"bookings\""
input bookings_avg_order_by {
    facility_id: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
}

"Boolean expression to filter rows from the table \"bookings\". All fields are combined with a logical 'AND'."
input bookings_bool_exp {
    _and: [bookings_bool_exp!]
    _not: bookings_bool_exp
    _or: [bookings_bool_exp!]
    booking_status: Boolean_comparison_exp
    contact_name: String_comparison_exp
    contact_phone: String_comparison_exp
    created_at: timestamptz_comparison_exp
    facility: facilities_bool_exp
    facility_id: Int_comparison_exp
    id: uuid_comparison_exp
    payment_status: payment_status_enum_enum_comparison_exp
    payment_status_enum: payment_status_enum_bool_exp
    payments: payments_bool_exp
    reservation_date: date_comparison_exp
    reservation_end_time: timestamptz_comparison_exp
    reservation_start_time: timestamptz_comparison_exp
    slot: slots_bool_exp
    slot_id: bigint_comparison_exp
    split_amount: Int_comparison_exp
    split_members: Int_comparison_exp
    split_payment: Boolean_comparison_exp
    updated_at: timestamptz_comparison_exp
    user: user_bool_exp
    user_id: String_comparison_exp
}

"input type for incrementing numeric columns in table \"bookings\""
input bookings_inc_input {
    facility_id: Int
    slot_id: bigint
    split_amount: Int
    split_members: Int
}

"input type for inserting data into table \"bookings\""
input bookings_insert_input {
    booking_status: Boolean
    contact_name: String
    contact_phone: String
    created_at: timestamptz
    facility: facilities_obj_rel_insert_input
    facility_id: Int
    id: uuid
    payment_status: payment_status_enum_enum
    payment_status_enum: payment_status_enum_obj_rel_insert_input
    payments: payments_arr_rel_insert_input
    reservation_date: date
    reservation_end_time: timestamptz
    reservation_start_time: timestamptz
    slot: slots_obj_rel_insert_input
    slot_id: bigint
    split_amount: Int
    split_members: Int
    split_payment: Boolean
    updated_at: timestamptz
    user: user_obj_rel_insert_input
    user_id: String
}

"order by max() on columns of table \"bookings\""
input bookings_max_order_by {
    contact_name: order_by
    contact_phone: order_by
    created_at: order_by
    facility_id: order_by
    id: order_by
    reservation_date: order_by
    reservation_end_time: order_by
    reservation_start_time: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
    updated_at: order_by
    user_id: order_by
}

"order by min() on columns of table \"bookings\""
input bookings_min_order_by {
    contact_name: order_by
    contact_phone: order_by
    created_at: order_by
    facility_id: order_by
    id: order_by
    reservation_date: order_by
    reservation_end_time: order_by
    reservation_start_time: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
    updated_at: order_by
    user_id: order_by
}

"input type for inserting object relation for remote table \"bookings\""
input bookings_obj_rel_insert_input {
    data: bookings_insert_input!
    "on conflict condition"
    on_conflict: bookings_on_conflict
}

"on conflict condition type for table \"bookings\""
input bookings_on_conflict {
    constraint: bookings_constraint!
    update_columns: [bookings_update_column!]! = []
    where: bookings_bool_exp
}

"Ordering options when selecting data from \"bookings\"."
input bookings_order_by {
    booking_status: order_by
    contact_name: order_by
    contact_phone: order_by
    created_at: order_by
    facility: facilities_order_by
    facility_id: order_by
    id: order_by
    payment_status: order_by
    payment_status_enum: payment_status_enum_order_by
    payments_aggregate: payments_aggregate_order_by
    reservation_date: order_by
    reservation_end_time: order_by
    reservation_start_time: order_by
    slot: slots_order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
    split_payment: order_by
    updated_at: order_by
    user: user_order_by
    user_id: order_by
}

"primary key columns input for table: bookings"
input bookings_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"bookings\""
input bookings_set_input {
    booking_status: Boolean
    contact_name: String
    contact_phone: String
    created_at: timestamptz
    facility_id: Int
    id: uuid
    payment_status: payment_status_enum_enum
    reservation_date: date
    reservation_end_time: timestamptz
    reservation_start_time: timestamptz
    slot_id: bigint
    split_amount: Int
    split_members: Int
    split_payment: Boolean
    updated_at: timestamptz
    user_id: String
}

"order by stddev() on columns of table \"bookings\""
input bookings_stddev_order_by {
    facility_id: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
}

"order by stddev_pop() on columns of table \"bookings\""
input bookings_stddev_pop_order_by {
    facility_id: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
}

"order by stddev_samp() on columns of table \"bookings\""
input bookings_stddev_samp_order_by {
    facility_id: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
}

"order by sum() on columns of table \"bookings\""
input bookings_sum_order_by {
    facility_id: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
}

"order by var_pop() on columns of table \"bookings\""
input bookings_var_pop_order_by {
    facility_id: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
}

"order by var_samp() on columns of table \"bookings\""
input bookings_var_samp_order_by {
    facility_id: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
}

"order by variance() on columns of table \"bookings\""
input bookings_variance_order_by {
    facility_id: order_by
    slot_id: order_by
    split_amount: order_by
    split_members: order_by
}

"Boolean expression to compare columns of type \"date\". All fields are combined with logical 'AND'."
input date_comparison_exp {
    _eq: date
    _gt: date
    _gte: date
    _in: [date!]
    _is_null: Boolean
    _lt: date
    _lte: date
    _neq: date
    _nin: [date!]
}

"order by aggregate values of table \"facilities\""
input facilities_aggregate_order_by {
    avg: facilities_avg_order_by
    count: order_by
    max: facilities_max_order_by
    min: facilities_min_order_by
    stddev: facilities_stddev_order_by
    stddev_pop: facilities_stddev_pop_order_by
    stddev_samp: facilities_stddev_samp_order_by
    sum: facilities_sum_order_by
    var_pop: facilities_var_pop_order_by
    var_samp: facilities_var_samp_order_by
    variance: facilities_variance_order_by
}

"input type for inserting array relation for remote table \"facilities\""
input facilities_arr_rel_insert_input {
    data: [facilities_insert_input!]!
    "on conflict condition"
    on_conflict: facilities_on_conflict
}

"order by avg() on columns of table \"facilities\""
input facilities_avg_order_by {
    id: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"Boolean expression to filter rows from the table \"facilities\". All fields are combined with a logical 'AND'."
input facilities_bool_exp {
    _and: [facilities_bool_exp!]
    _not: facilities_bool_exp
    _or: [facilities_bool_exp!]
    bookings: bookings_bool_exp
    id: Int_comparison_exp
    name: String_comparison_exp
    price: Int_comparison_exp
    slots: slots_bool_exp
    sport: sport_bool_exp
    sport_id: Int_comparison_exp
    turf: turf_bool_exp
    turf_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"facilities\""
input facilities_inc_input {
    id: Int
    price: Int
    sport_id: Int
    turf_id: bigint
}

"input type for inserting data into table \"facilities\""
input facilities_insert_input {
    bookings: bookings_arr_rel_insert_input
    id: Int
    name: String
    price: Int
    slots: slots_arr_rel_insert_input
    sport: sport_obj_rel_insert_input
    sport_id: Int
    turf: turf_obj_rel_insert_input
    turf_id: bigint
}

"order by max() on columns of table \"facilities\""
input facilities_max_order_by {
    id: order_by
    name: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by min() on columns of table \"facilities\""
input facilities_min_order_by {
    id: order_by
    name: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"input type for inserting object relation for remote table \"facilities\""
input facilities_obj_rel_insert_input {
    data: facilities_insert_input!
    "on conflict condition"
    on_conflict: facilities_on_conflict
}

"on conflict condition type for table \"facilities\""
input facilities_on_conflict {
    constraint: facilities_constraint!
    update_columns: [facilities_update_column!]! = []
    where: facilities_bool_exp
}

"Ordering options when selecting data from \"facilities\"."
input facilities_order_by {
    bookings_aggregate: bookings_aggregate_order_by
    id: order_by
    name: order_by
    price: order_by
    slots_aggregate: slots_aggregate_order_by
    sport: sport_order_by
    sport_id: order_by
    turf: turf_order_by
    turf_id: order_by
}

"primary key columns input for table: facilities"
input facilities_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"facilities\""
input facilities_set_input {
    id: Int
    name: String
    price: Int
    sport_id: Int
    turf_id: bigint
}

"order by stddev() on columns of table \"facilities\""
input facilities_stddev_order_by {
    id: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by stddev_pop() on columns of table \"facilities\""
input facilities_stddev_pop_order_by {
    id: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by stddev_samp() on columns of table \"facilities\""
input facilities_stddev_samp_order_by {
    id: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by sum() on columns of table \"facilities\""
input facilities_sum_order_by {
    id: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by var_pop() on columns of table \"facilities\""
input facilities_var_pop_order_by {
    id: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by var_samp() on columns of table \"facilities\""
input facilities_var_samp_order_by {
    id: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by variance() on columns of table \"facilities\""
input facilities_variance_order_by {
    id: order_by
    price: order_by
    sport_id: order_by
    turf_id: order_by
}

"Boolean expression to compare columns of type \"float8\". All fields are combined with logical 'AND'."
input float8_comparison_exp {
    _eq: float8
    _gt: float8
    _gte: float8
    _in: [float8!]
    _is_null: Boolean
    _lt: float8
    _lte: float8
    _neq: float8
    _nin: [float8!]
}

"order by aggregate values of table \"images\""
input images_aggregate_order_by {
    avg: images_avg_order_by
    count: order_by
    max: images_max_order_by
    min: images_min_order_by
    stddev: images_stddev_order_by
    stddev_pop: images_stddev_pop_order_by
    stddev_samp: images_stddev_samp_order_by
    sum: images_sum_order_by
    var_pop: images_var_pop_order_by
    var_samp: images_var_samp_order_by
    variance: images_variance_order_by
}

"input type for inserting array relation for remote table \"images\""
input images_arr_rel_insert_input {
    data: [images_insert_input!]!
    "on conflict condition"
    on_conflict: images_on_conflict
}

"order by avg() on columns of table \"images\""
input images_avg_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
}

"Boolean expression to filter rows from the table \"images\". All fields are combined with a logical 'AND'."
input images_bool_exp {
    _and: [images_bool_exp!]
    _not: images_bool_exp
    _or: [images_bool_exp!]
    id: bigint_comparison_exp
    sport: sport_bool_exp
    sport_id: Int_comparison_exp
    turf: turf_bool_exp
    turf_id: bigint_comparison_exp
    url: String_comparison_exp
    user: user_bool_exp
    user_id: String_comparison_exp
}

"input type for incrementing numeric columns in table \"images\""
input images_inc_input {
    id: bigint
    sport_id: Int
    turf_id: bigint
}

"input type for inserting data into table \"images\""
input images_insert_input {
    id: bigint
    sport: sport_obj_rel_insert_input
    sport_id: Int
    turf: turf_obj_rel_insert_input
    turf_id: bigint
    url: String
    user: user_obj_rel_insert_input
    user_id: String
}

"order by max() on columns of table \"images\""
input images_max_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
    url: order_by
    user_id: order_by
}

"order by min() on columns of table \"images\""
input images_min_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
    url: order_by
    user_id: order_by
}

"on conflict condition type for table \"images\""
input images_on_conflict {
    constraint: images_constraint!
    update_columns: [images_update_column!]! = []
    where: images_bool_exp
}

"Ordering options when selecting data from \"images\"."
input images_order_by {
    id: order_by
    sport: sport_order_by
    sport_id: order_by
    turf: turf_order_by
    turf_id: order_by
    url: order_by
    user: user_order_by
    user_id: order_by
}

"primary key columns input for table: images"
input images_pk_columns_input {
    id: bigint!
}

"input type for updating data in table \"images\""
input images_set_input {
    id: bigint
    sport_id: Int
    turf_id: bigint
    url: String
    user_id: String
}

"order by stddev() on columns of table \"images\""
input images_stddev_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by stddev_pop() on columns of table \"images\""
input images_stddev_pop_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by stddev_samp() on columns of table \"images\""
input images_stddev_samp_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by sum() on columns of table \"images\""
input images_sum_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by var_pop() on columns of table \"images\""
input images_var_pop_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by var_samp() on columns of table \"images\""
input images_var_samp_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
}

"order by variance() on columns of table \"images\""
input images_variance_order_by {
    id: order_by
    sport_id: order_by
    turf_id: order_by
}

"Boolean expression to compare columns of type \"json\". All fields are combined with logical 'AND'."
input json_comparison_exp {
    _eq: json
    _gt: json
    _gte: json
    _in: [json!]
    _is_null: Boolean
    _lt: json
    _lte: json
    _neq: json
    _nin: [json!]
}

"Boolean expression to filter rows from the table \"payment_status_enum\". All fields are combined with a logical 'AND'."
input payment_status_enum_bool_exp {
    _and: [payment_status_enum_bool_exp!]
    _not: payment_status_enum_bool_exp
    _or: [payment_status_enum_bool_exp!]
    bookings: bookings_bool_exp
    description: String_comparison_exp
    status: String_comparison_exp
}

"Boolean expression to compare columns of type \"payment_status_enum_enum\". All fields are combined with logical 'AND'."
input payment_status_enum_enum_comparison_exp {
    _eq: payment_status_enum_enum
    _in: [payment_status_enum_enum!]
    _is_null: Boolean
    _neq: payment_status_enum_enum
    _nin: [payment_status_enum_enum!]
}

"input type for inserting data into table \"payment_status_enum\""
input payment_status_enum_insert_input {
    bookings: bookings_arr_rel_insert_input
    description: String
    status: String
}

"input type for inserting object relation for remote table \"payment_status_enum\""
input payment_status_enum_obj_rel_insert_input {
    data: payment_status_enum_insert_input!
    "on conflict condition"
    on_conflict: payment_status_enum_on_conflict
}

"on conflict condition type for table \"payment_status_enum\""
input payment_status_enum_on_conflict {
    constraint: payment_status_enum_constraint!
    update_columns: [payment_status_enum_update_column!]! = []
    where: payment_status_enum_bool_exp
}

"Ordering options when selecting data from \"payment_status_enum\"."
input payment_status_enum_order_by {
    bookings_aggregate: bookings_aggregate_order_by
    description: order_by
    status: order_by
}

"primary key columns input for table: payment_status_enum"
input payment_status_enum_pk_columns_input {
    status: String!
}

"input type for updating data in table \"payment_status_enum\""
input payment_status_enum_set_input {
    description: String
    status: String
}

"order by aggregate values of table \"payments\""
input payments_aggregate_order_by {
    count: order_by
    max: payments_max_order_by
    min: payments_min_order_by
}

"input type for inserting array relation for remote table \"payments\""
input payments_arr_rel_insert_input {
    data: [payments_insert_input!]!
    "on conflict condition"
    on_conflict: payments_on_conflict
}

"Boolean expression to filter rows from the table \"payments\". All fields are combined with a logical 'AND'."
input payments_bool_exp {
    _and: [payments_bool_exp!]
    _not: payments_bool_exp
    _or: [payments_bool_exp!]
    booking: bookings_bool_exp
    booking_id: uuid_comparison_exp
    created_at: timestamptz_comparison_exp
    id: uuid_comparison_exp
    payment_approved: Boolean_comparison_exp
    payment_obj: json_comparison_exp
    payment_status: String_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"payments\""
input payments_insert_input {
    booking: bookings_obj_rel_insert_input
    booking_id: uuid
    created_at: timestamptz
    id: uuid
    payment_approved: Boolean
    payment_obj: json
    payment_status: String
    updated_at: timestamptz
}

"order by max() on columns of table \"payments\""
input payments_max_order_by {
    booking_id: order_by
    created_at: order_by
    id: order_by
    payment_status: order_by
    updated_at: order_by
}

"order by min() on columns of table \"payments\""
input payments_min_order_by {
    booking_id: order_by
    created_at: order_by
    id: order_by
    payment_status: order_by
    updated_at: order_by
}

"on conflict condition type for table \"payments\""
input payments_on_conflict {
    constraint: payments_constraint!
    update_columns: [payments_update_column!]! = []
    where: payments_bool_exp
}

"Ordering options when selecting data from \"payments\"."
input payments_order_by {
    booking: bookings_order_by
    booking_id: order_by
    created_at: order_by
    id: order_by
    payment_approved: order_by
    payment_obj: order_by
    payment_status: order_by
    updated_at: order_by
}

"primary key columns input for table: payments"
input payments_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"payments\""
input payments_set_input {
    booking_id: uuid
    created_at: timestamptz
    id: uuid
    payment_approved: Boolean
    payment_obj: json
    payment_status: String
    updated_at: timestamptz
}

"order by aggregate values of table \"rating\""
input rating_aggregate_order_by {
    avg: rating_avg_order_by
    count: order_by
    max: rating_max_order_by
    min: rating_min_order_by
    stddev: rating_stddev_order_by
    stddev_pop: rating_stddev_pop_order_by
    stddev_samp: rating_stddev_samp_order_by
    sum: rating_sum_order_by
    var_pop: rating_var_pop_order_by
    var_samp: rating_var_samp_order_by
    variance: rating_variance_order_by
}

"input type for inserting array relation for remote table \"rating\""
input rating_arr_rel_insert_input {
    data: [rating_insert_input!]!
    "on conflict condition"
    on_conflict: rating_on_conflict
}

"order by avg() on columns of table \"rating\""
input rating_avg_order_by {
    id: order_by
    ratings: order_by
    turf_id: order_by
}

"Boolean expression to filter rows from the table \"rating\". All fields are combined with a logical 'AND'."
input rating_bool_exp {
    _and: [rating_bool_exp!]
    _not: rating_bool_exp
    _or: [rating_bool_exp!]
    id: bigint_comparison_exp
    ratings: Int_comparison_exp
    review: String_comparison_exp
    turf: turf_bool_exp
    turf_id: bigint_comparison_exp
    user: user_bool_exp
    user_id: String_comparison_exp
}

"input type for incrementing numeric columns in table \"rating\""
input rating_inc_input {
    id: bigint
    ratings: Int
    turf_id: bigint
}

"input type for inserting data into table \"rating\""
input rating_insert_input {
    id: bigint
    ratings: Int
    review: String
    turf: turf_obj_rel_insert_input
    turf_id: bigint
    user: user_obj_rel_insert_input
    user_id: String
}

"order by max() on columns of table \"rating\""
input rating_max_order_by {
    id: order_by
    ratings: order_by
    review: order_by
    turf_id: order_by
    user_id: order_by
}

"order by min() on columns of table \"rating\""
input rating_min_order_by {
    id: order_by
    ratings: order_by
    review: order_by
    turf_id: order_by
    user_id: order_by
}

"on conflict condition type for table \"rating\""
input rating_on_conflict {
    constraint: rating_constraint!
    update_columns: [rating_update_column!]! = []
    where: rating_bool_exp
}

"Ordering options when selecting data from \"rating\"."
input rating_order_by {
    id: order_by
    ratings: order_by
    review: order_by
    turf: turf_order_by
    turf_id: order_by
    user: user_order_by
    user_id: order_by
}

"primary key columns input for table: rating"
input rating_pk_columns_input {
    id: bigint!
}

"input type for updating data in table \"rating\""
input rating_set_input {
    id: bigint
    ratings: Int
    review: String
    turf_id: bigint
    user_id: String
}

"order by stddev() on columns of table \"rating\""
input rating_stddev_order_by {
    id: order_by
    ratings: order_by
    turf_id: order_by
}

"order by stddev_pop() on columns of table \"rating\""
input rating_stddev_pop_order_by {
    id: order_by
    ratings: order_by
    turf_id: order_by
}

"order by stddev_samp() on columns of table \"rating\""
input rating_stddev_samp_order_by {
    id: order_by
    ratings: order_by
    turf_id: order_by
}

"order by sum() on columns of table \"rating\""
input rating_sum_order_by {
    id: order_by
    ratings: order_by
    turf_id: order_by
}

"order by var_pop() on columns of table \"rating\""
input rating_var_pop_order_by {
    id: order_by
    ratings: order_by
    turf_id: order_by
}

"order by var_samp() on columns of table \"rating\""
input rating_var_samp_order_by {
    id: order_by
    ratings: order_by
    turf_id: order_by
}

"order by variance() on columns of table \"rating\""
input rating_variance_order_by {
    id: order_by
    ratings: order_by
    turf_id: order_by
}

"order by aggregate values of table \"slots\""
input slots_aggregate_order_by {
    avg: slots_avg_order_by
    count: order_by
    max: slots_max_order_by
    min: slots_min_order_by
    stddev: slots_stddev_order_by
    stddev_pop: slots_stddev_pop_order_by
    stddev_samp: slots_stddev_samp_order_by
    sum: slots_sum_order_by
    var_pop: slots_var_pop_order_by
    var_samp: slots_var_samp_order_by
    variance: slots_variance_order_by
}

"input type for inserting array relation for remote table \"slots\""
input slots_arr_rel_insert_input {
    data: [slots_insert_input!]!
    "on conflict condition"
    on_conflict: slots_on_conflict
}

"order by avg() on columns of table \"slots\""
input slots_avg_order_by {
    facility_id: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"slots\". All fields are combined with a logical 'AND'."
input slots_bool_exp {
    _and: [slots_bool_exp!]
    _not: slots_bool_exp
    _or: [slots_bool_exp!]
    bookings: bookings_bool_exp
    end_time: timestamptz_comparison_exp
    facility: facilities_bool_exp
    facility_id: Int_comparison_exp
    id: bigint_comparison_exp
    start_time: timestamptz_comparison_exp
}

"input type for incrementing numeric columns in table \"slots\""
input slots_inc_input {
    facility_id: Int
    id: bigint
}

"input type for inserting data into table \"slots\""
input slots_insert_input {
    bookings: bookings_arr_rel_insert_input
    end_time: timestamptz
    facility: facilities_obj_rel_insert_input
    facility_id: Int
    id: bigint
    start_time: timestamptz
}

"order by max() on columns of table \"slots\""
input slots_max_order_by {
    end_time: order_by
    facility_id: order_by
    id: order_by
    start_time: order_by
}

"order by min() on columns of table \"slots\""
input slots_min_order_by {
    end_time: order_by
    facility_id: order_by
    id: order_by
    start_time: order_by
}

"input type for inserting object relation for remote table \"slots\""
input slots_obj_rel_insert_input {
    data: slots_insert_input!
    "on conflict condition"
    on_conflict: slots_on_conflict
}

"on conflict condition type for table \"slots\""
input slots_on_conflict {
    constraint: slots_constraint!
    update_columns: [slots_update_column!]! = []
    where: slots_bool_exp
}

"Ordering options when selecting data from \"slots\"."
input slots_order_by {
    bookings_aggregate: bookings_aggregate_order_by
    end_time: order_by
    facility: facilities_order_by
    facility_id: order_by
    id: order_by
    start_time: order_by
}

"primary key columns input for table: slots"
input slots_pk_columns_input {
    id: bigint!
}

"input type for updating data in table \"slots\""
input slots_set_input {
    end_time: timestamptz
    facility_id: Int
    id: bigint
    start_time: timestamptz
}

"order by stddev() on columns of table \"slots\""
input slots_stddev_order_by {
    facility_id: order_by
    id: order_by
}

"order by stddev_pop() on columns of table \"slots\""
input slots_stddev_pop_order_by {
    facility_id: order_by
    id: order_by
}

"order by stddev_samp() on columns of table \"slots\""
input slots_stddev_samp_order_by {
    facility_id: order_by
    id: order_by
}

"order by sum() on columns of table \"slots\""
input slots_sum_order_by {
    facility_id: order_by
    id: order_by
}

"order by var_pop() on columns of table \"slots\""
input slots_var_pop_order_by {
    facility_id: order_by
    id: order_by
}

"order by var_samp() on columns of table \"slots\""
input slots_var_samp_order_by {
    facility_id: order_by
    id: order_by
}

"order by variance() on columns of table \"slots\""
input slots_variance_order_by {
    facility_id: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"sport\". All fields are combined with a logical 'AND'."
input sport_bool_exp {
    _and: [sport_bool_exp!]
    _not: sport_bool_exp
    _or: [sport_bool_exp!]
    disabled: Boolean_comparison_exp
    facilities: facilities_bool_exp
    id: Int_comparison_exp
    images: images_bool_exp
    name: String_comparison_exp
}

"input type for incrementing numeric columns in table \"sport\""
input sport_inc_input {
    id: Int
}

"input type for inserting data into table \"sport\""
input sport_insert_input {
    disabled: Boolean
    facilities: facilities_arr_rel_insert_input
    id: Int
    images: images_arr_rel_insert_input
    name: String
}

"input type for inserting object relation for remote table \"sport\""
input sport_obj_rel_insert_input {
    data: sport_insert_input!
    "on conflict condition"
    on_conflict: sport_on_conflict
}

"on conflict condition type for table \"sport\""
input sport_on_conflict {
    constraint: sport_constraint!
    update_columns: [sport_update_column!]! = []
    where: sport_bool_exp
}

"Ordering options when selecting data from \"sport\"."
input sport_order_by {
    disabled: order_by
    facilities_aggregate: facilities_aggregate_order_by
    id: order_by
    images_aggregate: images_aggregate_order_by
    name: order_by
}

"primary key columns input for table: sport"
input sport_pk_columns_input {
    name: String!
}

"input type for updating data in table \"sport\""
input sport_set_input {
    disabled: Boolean
    id: Int
    name: String
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"order by aggregate values of table \"turf\""
input turf_aggregate_order_by {
    avg: turf_avg_order_by
    count: order_by
    max: turf_max_order_by
    min: turf_min_order_by
    stddev: turf_stddev_order_by
    stddev_pop: turf_stddev_pop_order_by
    stddev_samp: turf_stddev_samp_order_by
    sum: turf_sum_order_by
    var_pop: turf_var_pop_order_by
    var_samp: turf_var_samp_order_by
    variance: turf_variance_order_by
}

"input type for inserting array relation for remote table \"turf\""
input turf_arr_rel_insert_input {
    data: [turf_insert_input!]!
    "on conflict condition"
    on_conflict: turf_on_conflict
}

"order by avg() on columns of table \"turf\""
input turf_avg_order_by {
    id: order_by
    pincode: order_by
}

"Boolean expression to filter rows from the table \"turf\". All fields are combined with a logical 'AND'."
input turf_bool_exp {
    _and: [turf_bool_exp!]
    _not: turf_bool_exp
    _or: [turf_bool_exp!]
    address: String_comparison_exp
    city: String_comparison_exp
    facilities: facilities_bool_exp
    id: bigint_comparison_exp
    images: images_bool_exp
    name: String_comparison_exp
    pincode: Int_comparison_exp
    rating: float8_comparison_exp
    ratings: rating_bool_exp
    state: String_comparison_exp
    vendor_id: String_comparison_exp
    vendor_profile: vendor_bool_exp
}

"input type for incrementing numeric columns in table \"turf\""
input turf_inc_input {
    id: bigint
    pincode: Int
}

"input type for inserting data into table \"turf\""
input turf_insert_input {
    address: String
    city: String
    facilities: facilities_arr_rel_insert_input
    id: bigint
    images: images_arr_rel_insert_input
    name: String
    pincode: Int
    ratings: rating_arr_rel_insert_input
    state: String
    vendor_id: String
    vendor_profile: vendor_obj_rel_insert_input
}

"order by max() on columns of table \"turf\""
input turf_max_order_by {
    address: order_by
    city: order_by
    id: order_by
    name: order_by
    pincode: order_by
    state: order_by
    vendor_id: order_by
}

"order by min() on columns of table \"turf\""
input turf_min_order_by {
    address: order_by
    city: order_by
    id: order_by
    name: order_by
    pincode: order_by
    state: order_by
    vendor_id: order_by
}

"input type for inserting object relation for remote table \"turf\""
input turf_obj_rel_insert_input {
    data: turf_insert_input!
    "on conflict condition"
    on_conflict: turf_on_conflict
}

"on conflict condition type for table \"turf\""
input turf_on_conflict {
    constraint: turf_constraint!
    update_columns: [turf_update_column!]! = []
    where: turf_bool_exp
}

"Ordering options when selecting data from \"turf\"."
input turf_order_by {
    address: order_by
    city: order_by
    facilities_aggregate: facilities_aggregate_order_by
    id: order_by
    images_aggregate: images_aggregate_order_by
    name: order_by
    pincode: order_by
    rating: order_by
    ratings_aggregate: rating_aggregate_order_by
    state: order_by
    vendor_id: order_by
    vendor_profile: vendor_order_by
}

"primary key columns input for table: turf"
input turf_pk_columns_input {
    id: bigint!
}

"input type for updating data in table \"turf\""
input turf_set_input {
    address: String
    city: String
    id: bigint
    name: String
    pincode: Int
    state: String
    vendor_id: String
}

"order by stddev() on columns of table \"turf\""
input turf_stddev_order_by {
    id: order_by
    pincode: order_by
}

"order by stddev_pop() on columns of table \"turf\""
input turf_stddev_pop_order_by {
    id: order_by
    pincode: order_by
}

"order by stddev_samp() on columns of table \"turf\""
input turf_stddev_samp_order_by {
    id: order_by
    pincode: order_by
}

"order by sum() on columns of table \"turf\""
input turf_sum_order_by {
    id: order_by
    pincode: order_by
}

"order by var_pop() on columns of table \"turf\""
input turf_var_pop_order_by {
    id: order_by
    pincode: order_by
}

"order by var_samp() on columns of table \"turf\""
input turf_var_samp_order_by {
    id: order_by
    pincode: order_by
}

"order by variance() on columns of table \"turf\""
input turf_variance_order_by {
    id: order_by
    pincode: order_by
}

"Boolean expression to filter rows from the table \"user\". All fields are combined with a logical 'AND'."
input user_bool_exp {
    _and: [user_bool_exp!]
    _not: user_bool_exp
    _or: [user_bool_exp!]
    bookings: bookings_bool_exp
    email: String_comparison_exp
    images: images_bool_exp
    name: String_comparison_exp
    nickname: String_comparison_exp
    picture: String_comparison_exp
    ratings: rating_bool_exp
    user_id: String_comparison_exp
    user_profile: user_profile_bool_exp
    vendor: vendor_bool_exp
}

"input type for inserting data into table \"user\""
input user_insert_input {
    bookings: bookings_arr_rel_insert_input
    email: String
    images: images_arr_rel_insert_input
    name: String
    nickname: String
    picture: String
    ratings: rating_arr_rel_insert_input
    user_id: String
    user_profile: user_profile_obj_rel_insert_input
    vendor: vendor_obj_rel_insert_input
}

"input type for inserting object relation for remote table \"user\""
input user_obj_rel_insert_input {
    data: user_insert_input!
    "on conflict condition"
    on_conflict: user_on_conflict
}

"on conflict condition type for table \"user\""
input user_on_conflict {
    constraint: user_constraint!
    update_columns: [user_update_column!]! = []
    where: user_bool_exp
}

"Ordering options when selecting data from \"user\"."
input user_order_by {
    bookings_aggregate: bookings_aggregate_order_by
    email: order_by
    images_aggregate: images_aggregate_order_by
    name: order_by
    nickname: order_by
    picture: order_by
    ratings_aggregate: rating_aggregate_order_by
    user_id: order_by
    user_profile: user_profile_order_by
    vendor: vendor_order_by
}

"primary key columns input for table: user"
input user_pk_columns_input {
    user_id: String!
}

"Boolean expression to filter rows from the table \"user_profile\". All fields are combined with a logical 'AND'."
input user_profile_bool_exp {
    _and: [user_profile_bool_exp!]
    _not: user_profile_bool_exp
    _or: [user_profile_bool_exp!]
    default_city: String_comparison_exp
    name: String_comparison_exp
    phone_number: String_comparison_exp
    user: user_bool_exp
    user_id: String_comparison_exp
}

"input type for inserting data into table \"user_profile\""
input user_profile_insert_input {
    default_city: String
    name: String
    phone_number: String
    user: user_obj_rel_insert_input
    user_id: String
}

"input type for inserting object relation for remote table \"user_profile\""
input user_profile_obj_rel_insert_input {
    data: user_profile_insert_input!
    "on conflict condition"
    on_conflict: user_profile_on_conflict
}

"on conflict condition type for table \"user_profile\""
input user_profile_on_conflict {
    constraint: user_profile_constraint!
    update_columns: [user_profile_update_column!]! = []
    where: user_profile_bool_exp
}

"Ordering options when selecting data from \"user_profile\"."
input user_profile_order_by {
    default_city: order_by
    name: order_by
    phone_number: order_by
    user: user_order_by
    user_id: order_by
}

"primary key columns input for table: user_profile"
input user_profile_pk_columns_input {
    user_id: String!
}

"input type for updating data in table \"user_profile\""
input user_profile_set_input {
    default_city: String
    name: String
    phone_number: String
    user_id: String
}

"input type for updating data in table \"user\""
input user_set_input {
    email: String
    name: String
    nickname: String
    picture: String
    user_id: String
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}

"Boolean expression to filter rows from the table \"vendor\". All fields are combined with a logical 'AND'."
input vendor_bool_exp {
    _and: [vendor_bool_exp!]
    _not: vendor_bool_exp
    _or: [vendor_bool_exp!]
    about: String_comparison_exp
    address: String_comparison_exp
    birthDate: date_comparison_exp
    city: String_comparison_exp
    company: String_comparison_exp
    country: String_comparison_exp
    name: String_comparison_exp
    payment_details: String_comparison_exp
    phone_number: String_comparison_exp
    state: String_comparison_exp
    turfs: turf_bool_exp
    user: user_bool_exp
    user_id: String_comparison_exp
    website: String_comparison_exp
}

"input type for inserting data into table \"vendor\""
input vendor_insert_input {
    about: String
    address: String
    birthDate: date
    city: String
    company: String
    country: String
    name: String
    payment_details: String
    phone_number: String
    state: String
    turfs: turf_arr_rel_insert_input
    user: user_obj_rel_insert_input
    user_id: String
    website: String
}

"input type for inserting object relation for remote table \"vendor\""
input vendor_obj_rel_insert_input {
    data: vendor_insert_input!
    "on conflict condition"
    on_conflict: vendor_on_conflict
}

"on conflict condition type for table \"vendor\""
input vendor_on_conflict {
    constraint: vendor_constraint!
    update_columns: [vendor_update_column!]! = []
    where: vendor_bool_exp
}

"Ordering options when selecting data from \"vendor\"."
input vendor_order_by {
    about: order_by
    address: order_by
    birthDate: order_by
    city: order_by
    company: order_by
    country: order_by
    name: order_by
    payment_details: order_by
    phone_number: order_by
    state: order_by
    turfs_aggregate: turf_aggregate_order_by
    user: user_order_by
    user_id: order_by
    website: order_by
}

"primary key columns input for table: vendor"
input vendor_pk_columns_input {
    user_id: String!
}

"input type for updating data in table \"vendor\""
input vendor_set_input {
    about: String
    address: String
    birthDate: date
    city: String
    company: String
    country: String
    name: String
    payment_details: String
    phone_number: String
    state: String
    user_id: String
    website: String
}


scalar bigint

scalar date

scalar float8

scalar json

scalar timestamptz

scalar uuid
